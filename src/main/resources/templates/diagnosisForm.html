<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>성향 진단하기</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @keyframes fadeInUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fadeInUp {
            animation: fadeInUp 0.5s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        .animate-fadeIn {
            animation: fadeIn 0.3s ease-out;
        }
        .questions-container {
            transition: transform 0.5s ease-in-out;
        }
        .transition-opacity {
            transition: opacity 0.5s ease-out;
        }
    </style>
</head>
<body class="min-h-screen bg-gray-100 flex items-center justify-center">
<div class="w-full max-w-4xl h-[80vh] bg-white rounded-lg shadow-xl overflow-hidden animate-fadeInUp">
    <div class="p-6 h-full flex flex-col justify-between relative">
        <div id="start" class="text-center flex flex-col justify-center h-full">
            <h1 class="text-5xl font-bold mb-16">성향 진단하기!</h1>
            <button onclick="startSurvey()" class="bg-indigo-500 hover:bg-indigo-600 active:bg-indigo-700 text-white text-2xl py-4 px-8 mx-auto rounded-md transition-colors duration-200">
                시작하기
            </button>
        </div>

        <div id="questions" class="h-full flex flex-col justify-between hidden">
            <div class="flex h-full overflow-hidden">
                <div id="questionsContainer" class="flex questions-container">
                    <!-- 질문들이 동적으로 추가될 예정 -->
                </div>
            </div>
            <div class="flex justify-between mt-4">
                <button onclick="handlePrev()" id="prevButton" class="text-xl py-2 px-4 transition-colors duration-200 disabled:opacity-50 bg-gray-500 hover:bg-gray-600 text-white rounded-md">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 inline-block mr-2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
                    </svg>
                    이전
                </button>
                <button onclick="handleNext()" id="nextButton" class="text-xl py-2 px-4 transition-colors duration-200 bg-gray-500 hover:bg-gray-600 text-white rounded-md">
                    다음
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 inline-block ml-2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" />
                    </svg>
                </button>
            </div>
        </div>

        <div id="end" class="text-center flex flex-col justify-center h-full hidden">
            <h2 class="text-5xl font-bold mb-16">진단 완료!</h2>
            <button onclick="handleCheckResults()" class="bg-green-500 hover:bg-green-600 active:bg-green-700 text-white text-2xl py-4 px-8 mx-auto rounded-md transition-colors duration-200">
                결과 확인하기
            </button>
        </div>

        <div id="alerts" class="absolute bottom-20 left-4 right-4 space-y-2">
            <!-- 알림이 동적으로 추가될 예정 -->
        </div>
    </div>
</div>

<script>
    // 설문 질문 배열
    const questions = [
        { text: "나 슬퍼서 뺑 쌌어", answers: ["예", "아니오"] },
        { text: "친구랑 놀기 좋아해", answers: ["예", "아니오"] },
        { text: "새로운 것 배우는 게 재미있어", answers: ["예", "아니오"] },
    ];

    let currentQuestion = 0; // 현재 질문 인덱스를 저장하는 변수
    let answers = new Array(questions.length).fill(''); // 사용자의 답변을 저장하는 배열

    // 설문 시작 함수
    function startSurvey() {
        document.getElementById('start').classList.add('hidden'); // 시작 화면 숨기기
        document.getElementById('questions').classList.remove('hidden'); // 질문 섹션 보이기
        renderQuestions(); // 질문 렌더링
    }

    // 모든 질문을 동적으로 렌더링하는 함수
    function renderQuestions() {
        const container = document.getElementById('questionsContainer');
        container.innerHTML = ''; // 이전 질문들 삭제
        questions.forEach((question, index) => {
            const div = document.createElement('div');
            div.className = `w-full flex-shrink-0 flex flex-col justify-center items-center`;
            div.innerHTML = `
                    <h2 class="text-4xl mb-16 text-center">${question.text}</h2> <!-- 질문과 예/아니오 버튼 사이의 간격을 넓히기 위해 mb-16으로 설정 -->
                    <div class="flex justify-center space-x-16 mb-8 w-full"> <!-- 예/아니오 버튼 사이의 간격을 넓히기 위해 space-x-16으로 설정 -->
                        ${question.answers.map((answer, answerIndex) => `
                            <button
                                onclick="handleAnswer('${answer}', ${index}, ${answerIndex})"
                                class="answer-btn text-2xl py-4 px-8 transition-all duration-200 w-1/3 rounded-md ${
                answers[index] === answer
                    ? answerIndex === 0
                        ? "bg-green-600 ring-4 ring-green-300 shadow-lg"
                        : "bg-red-600 ring-4 ring-red-300 shadow-lg"
                    : answerIndex === 0
                        ? "bg-green-400 hover:bg-green-500 active:bg-green-600"
                        : "bg-red-400 hover:bg-red-500 active:bg-red-600"
            }"
                            >
                                ${answer}
                            </button>
                        `).join('')}
                    </div>
                `;
            container.appendChild(div); // 질문을 컨테이너에 추가
        });
        updateNavButtons(); // 이전/다음 버튼 업데이트
        updateQuestionPosition(); // 현재 질문 위치 업데이트
    }

    // 질문 컨테이너의 위치를 업데이트하는 함수
    function updateQuestionPosition() {
        const container = document.getElementById('questionsContainer');
        container.style.transform = `translateX(-${currentQuestion * 100}%)`; // 현재 질문으로 슬라이드 이동
    }

    // 사용자가 답변을 선택했을 때 호출되는 함수
    function handleAnswer(answer, questionIndex, answerIndex) {
        // 이미 선택된 답변을 다시 클릭하면 선택 해제
        if (answers[questionIndex] === answer) {
            answers[questionIndex] = ''; // 선택 해제
        } else {
            answers[questionIndex] = answer; // 선택된 답변 저장
            if (currentQuestion < questions.length - 1) {
                currentQuestion++; // 다음 질문으로 자동 이동
            } else {
                checkCompletion(); // 모든 질문에 답변했는지 확인
            }
        }
        renderQuestions(); // 질문 다시 렌더링
    }

    // '다음' 버튼 클릭 시 호출되는 함수
    function handleNext() {
        if (currentQuestion < questions.length - 1) {
            currentQuestion++; // 다음 질문으로 이동
            updateQuestionPosition();
        } else {
            checkCompletion(); // 모든 질문에 답변했는지 확인
        }
        updateNavButtons(); // 버튼 업데이트
    }

    // '이전' 버튼 클릭 시 호출되는 함수
    function handlePrev() {
        if (currentQuestion > 0) {
            currentQuestion--; // 이전 질문으로 이동
            updateQuestionPosition();
        }
        updateNavButtons(); // 버튼 업데이트
    }

    // 이전/다음 버튼의 상태를 업데이트하는 함수
    function updateNavButtons() {
        const prevButton = document.getElementById('prevButton');
        const nextButton = document.getElementById('nextButton');

        // 첫 번째 질문에서는 '이전' 버튼 비활성화
        prevButton.disabled = currentQuestion === 0;
        prevButton.classList.toggle('opacity-50', currentQuestion === 0);

        // 마지막 질문에서는 '다음' 버튼을 '완료'로 변경
        if (currentQuestion === questions.length - 1) {
            nextButton.textContent = "완료";
            nextButton.classList.add('bg-green-500', 'hover:bg-green-600');
            nextButton.classList.remove('bg-gray-500', 'hover:bg-gray-600');
            nextButton.innerHTML = '완료';
        } else {
            nextButton.classList.add('bg-gray-500', 'hover:bg-gray-600');
            nextButton.classList.remove('bg-green-500', 'hover:bg-green-600');
            nextButton.innerHTML = `
                    다음
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-6 h-6 inline-block ml-2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" />
                    </svg>
                `;
        }
    }

    // 모든 질문에 답변했는지 확인하는 함수
    function checkCompletion() {
        if (answers.every(answer => answer !== '')) { // 모든 질문에 답변한 경우
            document.getElementById('questions').classList.add('hidden'); // 질문 섹션 숨기기
            document.getElementById('end').classList.remove('hidden'); // 완료 화면 보이기
        }
    }

    // 설문 결과 확인 버튼 클릭 시 호출되는 함수

    // 설문 답변을 MBTI 점수로 변환하는 함수
    function convertAnswersToMbtiScores(answers) {
        let eiScore = answers[0] === "예" ? "E" : "I";
        let snScore = answers[1] === "예" ? "S" : "N";
        let tfScore = answers[2] === "예" ? "T" : "F";
        let jpScore = "J"; // 추가 질문이 없어서 기본값 설정 (필요시 추가 질문과 로직 추가)

        return {
            eiScore: eiScore,
            snScore: snScore,
            tfScore: tfScore,
            jpScore: jpScore
        };
    }
    function handleCheckResults() {
        if (answers.every(answer => answer !== '')) { // 모든 질문에 답변한 경우
            const mbtiScoresDto = convertAnswersToMbtiScores(answers);
            const childId = "1"; // 실제 자녀 ID를 사용해야 합니다.

            fetch(`/api/mbti/diagnose/${childId}`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify(mbtiScoresDto)
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('MBTI 진단 요청 실패');
                    }
                    return response.json();
                })
                .then(data => {
                    console.log("진단 결과:", data);
                    resetSurvey(); // 설문 초기화
                })
                .catch(error => {
                    console.error("오류 발생:", error);
                    addAlert('진단 결과를 전송하는 데 실패했습니다.');
                });
        } else {
            addAlert('모든 질문에 답변해주세요.'); // 답변하지 않은 질문이 있을 경우 알림 표시
        }
    }

    // 설문을 초기 상태로 재설정하는 함수
    function resetSurvey() {
        currentQuestion = 0; // 현재 질문 인덱스 초기화
        answers = new Array(questions.length).fill(''); // 모든 답변 초기화
        document.getElementById('end').classList.add('hidden'); // 완료 화면 숨기기
        document.getElementById('start').classList.remove('hidden'); // 시작 화면 보이기
    }

    // 알림 메시지를 추가하는 함수
    function addAlert(message) {
        const alertsContainer = document.getElementById('alerts');
        const alertDiv = document.createElement('div');
        alertDiv.className = 'bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative animate-fadeIn transition-opacity duration-500';
        alertDiv.innerHTML = `
                <strong class="font-bold">주의!</strong>
                <span class="block sm:inline">${message}</span>
            `;
        alertsContainer.prepend(alertDiv); // 새로운 알림을 상단에 추가

        // 알림 개수를 최대 2개로 제한
        while (alertsContainer.children.length > 2) {
            alertsContainer.removeChild(alertsContainer.lastChild); // 초과된 알림 삭제
        }

        // 3초 후 알림을 페이드아웃하고 삭제
        setTimeout(() => {
            alertDiv.style.opacity = '0';
            setTimeout(() => alertDiv.remove(), 500);
        }, 3000);
    }

    // 초기 질문 렌더링
    renderQuestions();
</script>
</body>
</html>
